<?
$pid_file = "/shares/Private/cron.pid";

$cmd = key($_REQUEST);
$cmds = array(
  'stop', 'start', 'restart', '--daemon'
);



$daemon = new daemon($pid_file);

switch($cmd) {
 case 'stop': $daemon->stop();die;
 case 'start': $daemon->start();die;
 case 'restart': $daemon->restart();die;
 case '--daemon':break;
 default:
  die("Invalid command $cmd");
}



define('SIGTERM', 15);

class daemon {
  //private $pid_file;
  //private $pid;
  function __construct($pid_file){
    $this->pid_file = $pid_file;
    $this->pid      = posix_getpid();
  }

  function is_running(){
    $running = is_file($this->pid_file)
               && ($pid = file_get_contents($this->pid_file) )
               && posix_kill($pid, 0);
    return $running ? $pid : false;
  }


  private function trace($msg){
    $cmd = "logger $msg";
    exec($cmd);
  }

  private function abort($msg){
    $this->trace($msg);
    die;
  }

  function restart(){
    $this->stop();
    $this->start();
  }

  function start(){
    if($this->is_running()) {
      $this->trace("Already running");
    } else {
      $cmd = "nohup php -q ".__FILE__." --daemon > /dev/null &";
      passthru($cmd);
      $this->trace("start fork");
    }
  }

  function stop(){
    if(!($pid = $this->is_running()))
      $this->trace("Not running..");
    else posix_kill($pid, SIGTERM);

    if(is_file($this->pid_file))
      unlink($this->pid_file);
    $this->trace("Stop $pid");
  }

  function daemonize(){
    if($this->is_running())
      die("Already running");

    file_put_contents($this->pid_file, $this->pid);
    $this->trace("Running daemon {$this->pid}");
  }

}




do {
  $sz = "df -h | grep /dev/sdf5";
  $df = exec($sz);

  preg_match("#/shares/[a-z0-9_-]+#i", $df, $out);
  $mount = $out[0];

  $ping = "$mount/ping";
  $challenge = file_get_contents($ping);

  $trace = "logger 'challenge was $challenge'";
  exec($trace);
  sleep(10);
} while(true);
